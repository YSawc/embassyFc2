package RegisterPkg {
    struct Register {
        a : logic  <7>,
        x : logic  <7>,
        y : logic  <7>,
        s : logic  <7>,
        p : PPkg::P   ,
        pc: logic  <7>,
    }

    function set_c (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b00000001
        } else {
            current_p & 8'b11111110
        };
    }

    function set_z (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b00000010
        } else {
            current_p & 8'b11111101
        };
    }

    function plus_within_vnz (
        current_p: ref   logic<8>,
        input_l  : input logic<8>,
        input_r  : input logic<8>,
    ) -> logic<8> {
        return tmp_plus_within_vnz(0, 0, 0, current_p, input_l, input_r);
    }

    function tmp_plus_within_vnz (
        byte_buf   : input logic<16>,
        is_overflow: input logic    ,
        output_data: input logic<8> ,
        current_p  : ref   logic<8> ,
        input_l    : input logic<8> ,
        input_r    : input logic<8> ,
    ) -> logic<8>  {
        byte_buf    = input_l + input_r;
        is_overflow = byte_buf >= 16'h100;
        set_v      (current_p, is_overflow);
        output_data = if is_overflow {
            input_l + input_r - 16'h100
        } else {
            input_l + input_r
        };
        set_nz(current_p, output_data);
        return output_data;
    }

    function add_three_with_carry (
        current_p: ref   logic<8>,
        input_1  : ref   logic<8>,
        input_2  : ref   logic<8>,
        input_3  : input logic<8>,
    ) {
        tmp_add_three_with_carry(0, current_p, input_1, input_2, input_3);
    }

    function tmp_add_three_with_carry (
        byte_buf : input logic<16>,
        current_p: ref   logic<8> ,
        input_1  : ref   logic<8> ,
        input_2  : ref   logic<8> ,
        input_3  : input logic<8> ,
    ) {
        byte_buf = input_2 + input_3;
        input_2  = utilPkg::wrapping_add(input_2, input_3);
        if byte_buf >= 16'h100 {
            set_c  (current_p, 1);
            input_1 = utilPkg::wrapping_add(input_1, 1);
        } else {
            set_c(current_p, 0);
        }
    }

    function set_v (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b01000000
        } else {
            current_p & 8'b10111111
        };
    }

    function set_n (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b10000000
        } else {
            current_p & 8'b01111111
        };
    }

    function set_nz (
        current_p : ref   logic<8>,
        input_data: input logic<8>,
    ) {
        set_z(current_p, input_data == 0);
        set_n(current_p, input_data >= 8'h80);
    }

    // var register: Register;

    // function init () -> void {
    //     register.a = 0;
    //     register.x = 0;
    //     register.y = 0;
    //     register.s = 8'hff;
    //     PPkg::init();
    //     register.p = 0;
    // }

    // enum Status: logic<3> {
    //     idle,
    //     working,
    // }

    // function set_a (
    //     data: input logic<7>,
    // ) -> void {
    //     register.a = data;
    // }

    // function get_a () -> logic<7> {
    //     return register.a;
    // }

    // function set_x (
    //     data: input logic<7>,
    // ) -> void {
    //     register.x = data;
    // }

    // function get_x () -> logic<7> {
    //     return register.a;
    // }

    // function set_y (
    //     data: input logic<7>,
    // ) -> void {
    //     register.y = data;
    // }

    // function get_y () -> logic<7> {
    //     return register.y;
    // }

    // function set_s (
    //     data: input logic<7>,
    // ) -> void {
    //     register.s = data;
    // }

    // function get_s () -> logic<7> {
    //     return register.s;
    // }

    // function set_pc (
    //     data: input logic<7>,
    // ) -> void {
    //     register.pc = data;
    // }

    // function get_pc () -> logic<7> {
    //     return register.pc;
    // }

    // function inc_pc (
    //     data: input logic<15>,
    // ) -> void {
    //     register.pc += data;
    // }

    // function dec_pc (
    //     data: input logic<15>,
    // ) -> void {
    //     register.pc -= data;
    // }
}
