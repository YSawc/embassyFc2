package RegisterPkg {
    struct Register {
        a : logic  <7>,
        x : logic  <7>,
        y : logic  <7>,
        s : logic  <7>,
        p : PPkg::P   ,
        pc: logic  <7>,
    }

    function set_c (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b00000001
        } else {
            current_p & 8'b11111110
        };
    }

    function set_z (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b00000010
        } else {
            current_p & 8'b11111101
        };
    }

    function set_i (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b00000100
        } else {
            current_p & 8'b11111011
        };
    }

    function set_d (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b00001000
        } else {
            current_p & 8'b11110111
        };
    }

    function plus_with_vnzc_and_plus_carry (
        current_p: ref   logic<8>,
        input_l  : input logic<8>,
        input_r  : input logic<8>,
    ) -> logic<8> {
        return tmp_plus_with_vnzc_and_plus_carry(0, 0, 0, 0, 0, current_p, input_l, input_r);
    }

    function tmp_plus_with_vnzc_and_plus_carry (
        byte_buf    : input logic<16>,
        is_overflow : input logic    ,
        output_data : input logic<8> ,
        is_data_plus: input logic    ,
        is_carry    : input logic    ,
        current_p   : ref   logic<8> ,
        input_l     : input logic<8> ,
        input_r     : input logic<8> ,
    ) -> logic<8>  {
        input_r  = input_r + ((current_p & 8'b00000001) != 0);
        byte_buf = input_l + input_r;
        is_carry = byte_buf >= 16'h100;
        set_c   (current_p, is_carry);
        return tmp_plus_with_vnz(0, 0, 0, 0, 0, 0, 0, current_p, input_l, input_r);
    }

    function plus_with_vnz (
        current_p: ref   logic<8>,
        input_l  : input logic<8>,
        input_r  : input logic<8>,
    ) -> logic<8> {
        return tmp_plus_with_vnz(0, 0, 0, 0, 0, 0, 0, current_p, input_l, input_r);
    }

    function tmp_plus_with_vnz (
        is_overflow   : input logic    ,
        output_data   : input logic<8> ,
        is_l_data_plus: input logic    ,
        is_r_data_plus: input logic    ,
        byte_buf      : input logic<16>,
        is_carry      : input logic    ,
        is_data_plus  : input logic    ,
        current_p     : ref   logic<8> ,
        input_l       : input logic<8> ,
        input_r       : input logic<8> ,
    ) -> logic<8>  {
        is_l_data_plus = (input_l & 8'b10000000) == 0;
        is_r_data_plus = (input_r & 8'b10000000) == 0;
        byte_buf       = input_l + input_r;
        is_carry       = byte_buf >= 16'h100;
        output_data    = if is_carry {
            input_l + input_r - 16'h100
        } else {
            input_l + input_r
        };
        is_data_plus = (output_data & 8'b10000000) == 0;
        is_overflow  = (is_data_plus != is_l_data_plus) && (is_data_plus != is_r_data_plus);
        set_v       (current_p, is_overflow);
        set_nz      (current_p, output_data);
        return output_data;
    }

    function add_three_with_carry (
        current_p: ref   logic<8>,
        input_1  : ref   logic<8>,
        input_2  : ref   logic<8>,
        input_3  : input logic<8>,
    ) {
        tmp_add_three_with_carry(0, current_p, input_1, input_2, input_3);
    }

    function tmp_add_three_with_carry (
        byte_buf : input logic<16>,
        current_p: ref   logic<8> ,
        input_1  : ref   logic<8> ,
        input_2  : ref   logic<8> ,
        input_3  : input logic<8> ,
    ) {
        byte_buf = input_2 + input_3;
        input_2  = utilPkg::wrapping_add(input_2, input_3);
        if byte_buf >= 16'h100 {
            set_c  (current_p, 1);
            input_1 = utilPkg::wrapping_add(input_1, 1);
        } else {
            set_c(current_p, 0);
        }
    }

    function set_v (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b01000000
        } else {
            current_p & 8'b10111111
        };
    }

    function set_n (
        current_p: ref   logic<8>,
        flag     : input logic   ,
    ) {
        current_p = if flag {
            current_p | 8'b10000000
        } else {
            current_p & 8'b01111111
        };
    }

    function set_nz (
        current_p : ref   logic<8>,
        input_data: input logic<8>,
    ) {
        set_z(current_p, input_data == 0);
        set_n(current_p, input_data >= 8'h80);
    }

    function compare_with_nzc (
        current_p : ref   logic<8>,
        left_data : input logic<8>,
        right_data: input logic<8>,
    ) {
        set_c(current_p, left_data >= right_data);
        set_z(current_p, left_data == right_data);
        if left_data <: right_data || left_data - right_data >= 8'h80 {
            set_n(current_p, 1);
        } else {
            set_n(current_p, 0);
        }
    }
}
