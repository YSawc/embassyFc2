module AddrRef (
    CLK            : input  logic                    ,
    RST            : input  logic                    ,
    DATA_IN        : input  logic                    ,
    EN             : input  logic                    ,
    a              : input  logic                 <8>,
    addr_mode      : input  OperatorsPkg::AddrMode   ,
    imm_finish     : input  logic                    ,
    imm_data       : input  logic                 <8>,
    ope_read_finish: input  logic                 <8>,
    imm_en         : output logic                    ,
    addr_low       : output logic                 <8>,
    addr_high      : output logic                 <8>,
    busy           : output logic                    ,
    finish         : output logic                    ,
) {
    enum Status: logic<3> {
        idle,
        work,
    }

    var status         : Status   ;
    var n_status       : Status   ;
    var n_busy         : logic    ;
    var n_finish       : logic    ;
    var n_addr_low_reg : logic <8>;
    var n_addr_high_reg: logic <8>;
    var addr_low_reg   : logic <8>;
    var addr_high_reg  : logic <8>;
    var n_imm_en       : logic    ;

    var ope_en  : logic;
    var n_ope_en: logic;
    always_comb {
        n_status        = status;
        n_busy          = busy;
        n_finish        = finish;
        n_addr_low_reg  = addr_low_reg;
        n_addr_high_reg = addr_low_reg;
        n_imm_en        = imm_en;
        n_ope_en        = ope_en;
        if imm_finish {
            addr_low  = imm_data;
            addr_high = 0;
            n_status  = Status::idle;
            n_busy    = 0;
            n_finish  = 1;
            if ope_read_finish {
                n_ope_en = 1;
            }
        } else if finish {
            addr_low  = addr_low_reg;
            addr_high = addr_high_reg;
            // } else if inst_read_finish {
            //     addr_low  = operators[raw_inst_mode].ope_kind; // casted_ope_kind;
            //     addr_high = addr_high_reg;
        } else {
            addr_low  = 0;
            addr_high = 0;
        }
        case status {
            Status::idle: {
                if EN {
                    n_busy   = 1;
                    n_status = Status::work;
                }
            }
            Status::work: {
                if addr_mode == OperatorsPkg::AddrMode::Acc {
                    n_addr_low_reg  = a;
                    n_addr_high_reg = 0;
                    n_status        = Status::idle;
                    n_busy          = 0;
                    n_finish        = 1;
                } else if addr_mode == OperatorsPkg::AddrMode::Imm {
                    n_imm_en = 1;
                    n_status = Status::idle;
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::Abs {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::AbsX {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::AbsY {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::Zp {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::ZpX {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::ZpY {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::Impl {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::Rel {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::IndX {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::IndY {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::Ind {
                    //     //
                    // } else if casted_addr_mode == OperatorsPkg::OperatorsPkg::AddrMode::Nop {
                    //     //
                } else {
                    n_addr_low_reg  = 0;
                    n_addr_high_reg = 0;
                }
            }
        }
    }

    always_ff (posedge CLK, async_high RST) {
        if_reset {
            status        = Status::idle;
            finish        = 0;
            busy          = 0;
            addr_low_reg  = 0;
            addr_high_reg = 0;
            imm_en        = 0;
            ope_en        = 0;
        } else {
            status        = n_status;
            finish        = n_finish;
            busy          = n_busy;
            addr_low_reg  = n_addr_low_reg;
            addr_high_reg = n_addr_high_reg;
            imm_en        = n_imm_en;
            ope_en        = n_ope_en;
            finish        = n_finish;
        }
    }
}
