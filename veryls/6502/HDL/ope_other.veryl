module OpeOther (
    CLK         : input   logic                   ,
    RST         : input   logic                   ,
    EN          : input   logic                   ,
    ope_kind    : input   OperatorsPkg::OpeKind   ,
    addr_low    : input   logic                <8>,
    addr_high   : input   logic                <8>,
    register_slv: modport RegisterIf::Slave       ,
    register_mst: modport RegisterIf::Master      ,
    busy        : output  logic                   ,
    finish      : output  logic                   ,
) {
    enum Status: logic<2> {
        Idle,
        Work,
        Finish,
    }
    var status  : Status    ;
    var n_status: Status    ;
    var n_a     : logic <8> ;
    var n_x     : logic <8> ;
    var n_y     : logic <8> ;
    var n_s     : logic <8> ;
    var n_p     : logic <8> ;
    var n_pc    : logic <16>;
    var n_busy  : logic     ;
    var n_finish: logic     ;
    var ope_en  : logic     ;
    var n_ope_en: logic     ;

    always_comb {
        n_status = status;
        n_finish = finish;
        n_busy   = busy;
        n_ope_en = ope_en;
        n_a      = register_mst.a;
        n_x      = register_mst.x;
        n_y      = register_mst.y;
        n_s      = register_mst.s;
        n_p      = register_mst.p;
        n_pc     = register_mst.pc;
        case status {
            Status::Idle: {
                if EN {
                    n_a      = register_slv.a;
                    n_x      = register_slv.x;
                    n_y      = register_slv.y;
                    n_s      = register_slv.s;
                    n_p      = register_slv.p;
                    n_pc     = register_slv.pc;
                    n_busy   = 1;
                    n_status = Status::Work;
                }
            }
            Status::Work: {
                n_status = Status::Finish;
                n_busy   = 0;
                if ope_kind == OperatorsPkg::OpeKind::Inx {
                    n_x = RegisterPkg::add_with_vnz(n_p, n_x, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Dex {
                    n_x = RegisterPkg::sub_with_nz(n_p, n_x, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Iny {
                    n_y = RegisterPkg::add_with_vnz(n_p, n_y, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Dey {
                    n_y = RegisterPkg::sub_with_nz(n_p, n_y, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Clc {
                    RegisterPkg::set_c(n_p, 0);
                } else if ope_kind == OperatorsPkg::OpeKind::Sec {
                    RegisterPkg::set_c(n_p, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Cli {
                    RegisterPkg::set_i(n_p, 0);
                } else if ope_kind == OperatorsPkg::OpeKind::Sei {
                    RegisterPkg::set_i(n_p, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Cld {
                    RegisterPkg::set_d(n_p, 0);
                } else if ope_kind == OperatorsPkg::OpeKind::Sed {
                    RegisterPkg::set_d(n_p, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Clv {
                    RegisterPkg::set_v(n_p, 0);
                } else if ope_kind == OperatorsPkg::OpeKind::Jmp {
                    n_pc = (addr_high << 8) + addr_low;
                } else if ope_kind == OperatorsPkg::OpeKind::Bpl {
                    if (register_slv.p & 8'b10000000) == 0 {
                        n_pc = (addr_high << 8) + addr_low;
                    }
                } else if ope_kind == OperatorsPkg::OpeKind::Bmi {
                    if (register_slv.p & 8'b10000000) != 0 {
                        n_pc = (addr_high << 8) + addr_low;
                    }
                } else if ope_kind == OperatorsPkg::OpeKind::Bvc {
                    if (register_slv.p & 8'b01000000) == 0 {
                        n_pc = (addr_high << 8) + addr_low;
                    }
                } else if ope_kind == OperatorsPkg::OpeKind::Bvs {
                    if (register_slv.p & 8'b01000000) != 0 {
                        n_pc = (addr_high << 8) + addr_low;
                    }
                } else if ope_kind == OperatorsPkg::OpeKind::Bcc {
                    if (register_slv.p & 8'b00000001) == 0 {
                        n_pc = (addr_high << 8) + addr_low;
                    }
                } else if ope_kind == OperatorsPkg::OpeKind::Bcs {
                    if (register_slv.p & 8'b00000001) != 0 {
                        n_pc = (addr_high << 8) + addr_low;
                    }
                } else if ope_kind == OperatorsPkg::OpeKind::Bne {
                    if (register_slv.p & 8'b00000010) == 0 {
                        n_pc = (addr_high << 8) + addr_low;
                    }
                } else if ope_kind == OperatorsPkg::OpeKind::Beq {
                    if (register_slv.p & 8'b00000010) != 0 {
                        n_pc = (addr_high << 8) + addr_low;
                    }
                } else if ope_kind == OperatorsPkg::OpeKind::Tax {
                    n_x                 = register_slv.a;
                    RegisterPkg::set_nz(n_p, n_x);
                } else if ope_kind == OperatorsPkg::OpeKind::Txa {
                    n_a                 = register_slv.x;
                    RegisterPkg::set_nz(n_p, n_a);
                } else if ope_kind == OperatorsPkg::OpeKind::Tay {
                    n_y                 = register_slv.a;
                    RegisterPkg::set_nz(n_p, n_y);
                } else if ope_kind == OperatorsPkg::OpeKind::Tya {
                    n_a                 = register_slv.y;
                    RegisterPkg::set_nz(n_p, n_a);
                } else if ope_kind == OperatorsPkg::OpeKind::Tsx {
                    n_x                 = register_slv.s;
                    RegisterPkg::set_nz(n_p, n_x);
                } else if ope_kind == OperatorsPkg::OpeKind::Txs {
                    n_s = register_slv.x;
                }
            }
            Status::Finish: {
                n_status = Status::Idle;
            }
        }
        n_finish = n_status == Status::Finish;
    }

    always_ff (posedge CLK, async_high RST) {
        if_reset {
            status          = Status::Idle;
            finish          = 0;
            busy            = 0;
            ope_en          = 0;
            register_mst.a  = 0;
            register_mst.x  = 0;
            register_mst.y  = 0;
            register_mst.s  = 0;
            register_mst.p  = 0;
            register_mst.pc = 0;
        } else {
            status          = n_status;
            finish          = n_finish;
            busy            = n_busy;
            ope_en          = n_ope_en;
            register_mst.a  = n_a;
            register_mst.x  = n_x;
            register_mst.y  = n_y;
            register_mst.s  = n_s;
            register_mst.p  = n_p;
            register_mst.pc = n_pc;
        }
    }
}
