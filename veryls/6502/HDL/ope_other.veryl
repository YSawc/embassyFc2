module OpeOther (
    CLK      : input  logic                    ,
    RST      : input  logic                    ,
    EN       : input  logic                    ,
    ope_kind : input  OperatorsPkg::OpeKind    ,
    addr_low : input  logic                <8> ,
    addr_high: input  logic                <8> ,
    a_a      : input  logic                <8> ,
    a_x      : input  logic                <8> ,
    a_y      : input  logic                <8> ,
    a_p      : input  logic                <8> ,
    a        : output logic                <8> ,
    x        : output logic                <8> ,
    y        : output logic                <8> ,
    p        : output logic                <8> ,
    pc       : output logic                <16>,
    busy     : output logic                    ,
    finish   : output logic                    ,
) {
    enum Status: logic {
        idle,
        work,
    }
    var status  : Status    ;
    var n_status: Status    ;
    var n_a     : logic <8> ;
    var n_x     : logic <8> ;
    var n_y     : logic <8> ;
    var n_p     : logic <8> ;
    var n_pc    : logic <16>;
    var n_busy  : logic     ;
    var n_finish: logic     ;
    var ope_en  : logic     ;
    var n_ope_en: logic     ;

    always_comb {
        n_status = status;
        n_busy   = busy;
        n_finish = finish;
        n_ope_en = ope_en;
        n_a      = a;
        n_x      = x;
        n_y      = y;
        n_p      = p;
        n_pc     = pc;
        case status {
            Status::idle: {
                n_finish = 0;
                n_busy   = 1;
                n_a      = a_a;
                n_x      = a_x;
                n_y      = a_y;
                n_p      = a_p;
                if EN {
                    n_status = Status::work;
                }
            }
            Status::work: {
                n_status = Status::idle;
                n_busy   = 0;
                n_finish = 1;
                if ope_kind == OperatorsPkg::OpeKind::Inx {
                    n_x = RegisterPkg::add_with_vnz(n_p, n_x, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Dex {
                    n_x = RegisterPkg::sub_with_nz(n_p, n_x, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Iny {
                    n_y = RegisterPkg::add_with_vnz(n_p, n_y, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Dey {
                    n_y = RegisterPkg::sub_with_nz(n_p, n_y, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Clc {
                    RegisterPkg::set_c(n_p, 0);
                } else if ope_kind == OperatorsPkg::OpeKind::Sec {
                    RegisterPkg::set_c(n_p, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Cli {
                    RegisterPkg::set_i(n_p, 0);
                } else if ope_kind == OperatorsPkg::OpeKind::Sei {
                    RegisterPkg::set_i(n_p, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Cld {
                    RegisterPkg::set_d(n_p, 0);
                } else if ope_kind == OperatorsPkg::OpeKind::Sed {
                    RegisterPkg::set_d(n_p, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Clv {
                    RegisterPkg::set_v(n_p, 0);
                } else if ope_kind == OperatorsPkg::OpeKind::Jmp {
                    n_pc = (addr_high << 8) + addr_low;
                }
            }
        }
    }

    always_ff (posedge CLK, async_high RST) {
        if_reset {
            status = Status::idle;
            finish = 0;
            busy   = 0;
            ope_en = 0;
            a      = 0;
            x      = 0;
            y      = 0;
            p      = 0;
            pc     = 0;
        } else {
            status = n_status;
            finish = n_finish;
            busy   = n_busy;
            ope_en = n_ope_en;
            a      = n_a;
            x      = n_x;
            y      = n_y;
            p      = n_p;
            pc     = n_pc;
        }
    }
}
