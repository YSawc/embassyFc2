module main (
    CLK     : input  logic   ,
    RST     : input  logic   ,
    KEY     : input  logic<3>,
    GPIO_0_0: output logic   ,
    GPIO_0_1: input  logic   ,
) {
    var mode: ModePkg::CpuMode;
    inst modeHandler: ModeHandler (
        CLK              ,
        RST              ,
        DATA_IN: GPIO_0_1,
        mode             ,
    );

    var callback_read_enable : logic<8> = (mode == ModePkg::CpuMode::callback) && ~callback_tx_busy;
    var callback_return_value: int     ;
    var callback_read_rx_busy: int     ;
    inst callback_read_rx: uarty::Rx (
        CLK                            ,
        RST                            ,
        DATA_IN : GPIO_0_1             ,
        RE      : callback_read_enable ,
        data_out: callback_return_value,
        busy    : callback_read_rx_busy,
        finish  : 0                    ,
    );
    var callback_tx_enable: logic = (mode == ModePkg::CpuMode::callback) && ~callback_read_rx_busy;
    var callback_tx_out   : logic;
    var callback_tx_busy  : logic;
    var callback_tx_finish: logic;
    inst callback_tx: uarty::Tx (
        CLK                            ,
        RST                            ,
        WE      : callback_tx_enable   ,
        DATA_IN : callback_return_value,
        data_out: callback_tx_out      ,
        busy    : callback_tx_busy     ,
        finish  : callback_tx_finish   ,
    );

    var sequence_count_read_rx_enable: logic =
    // mode == ModePkg::CpuMode::sequence && ~callback_read_rx_busy && ~sequence_count_read_rx_busy
     mode == ModePkg::CpuMode::sequence && ~write_busy;
    var sequence_args_count        : logic<8>;
    var sequence_count_read_rx_busy: logic   ;
    inst sequence_count_read_rx: uarty::Rx (
        CLK                                    ,
        RST                                    ,
        DATA_IN : GPIO_0_1                     ,
        RE      : sequence_count_read_rx_enable,
        data_out: sequence_args_count          ,
        busy    : sequence_count_read_rx_busy  ,
        finish  : 0                            ,
    );

    var debug_enable   : logic    = (mode == ModePkg::CpuMode::debug) && ~write_busy;
    var debug_busy     : logic   ;
    var addr_low       : logic<8>;
    var addr_high      : logic<8>;
    var debug_tx_en    : logic   ;
    var memory_addr_low: logic<8>;
    // var memory_addr_low_tx_finish : logic   ;
    var memory_addr_high: logic<8>;
    // var memory_addr_high_tx_finish: logic   ;
    var memory_data: logic<8>;

    // var n_memory_addr_low_tx_finish : logic;
    // var n_memory_addr_high_tx_finish: logic;
    // always_comb {
    //     n_memory_addr_low_tx_finish  = memory_addr_low_tx_finish;
    //     n_memory_addr_high_tx_finish = memory_addr_high_tx_finish;
    //     if debug_tx_en && write_finish {
    //         if memory_addr_low_tx_finish {
    //             n_memory_addr_high_tx_finish = 1;
    //         } else {
    //             n_memory_addr_low_tx_finish = 1;
    //         }
    //     }
    // }
    // always_ff (posedge CLK, async_high RST) {
    //     if_reset {
    //         memory_addr_low_tx_finish  = 0;
    //         memory_addr_high_tx_finish = 0;
    //     } else {
    //         memory_addr_low_tx_finish  = n_memory_addr_low_tx_finish;
    //         memory_addr_high_tx_finish = n_memory_addr_high_tx_finish;
    //     }
    // }
    // var tx_finish: logic = memory_addr_high_tx_finish && memory_addr_low_tx_finish;
    inst debug: Debug (
        CLK                           ,
        RST                           ,
        DATA_IN         : GPIO_0_1    ,
        EN              : debug_enable,
        memory_data                   ,
        tx_finish                     ,
        addr_low                      ,
        addr_high                     ,
        busy            : debug_busy  ,
        WE              : debug_tx_en ,
        memory_addr_low               ,
        memory_addr_high              ,
    );

    // assign write_enable = cpu_enable && ~callback_read_rx_busy && ~sequence_count_read_rx_busy && (~debug_busy || (debug_tx_en && (~memory_addr_low_tx_finish || ~memory_addr_high_tx_finish)));
    var addr_low_tx_out   : logic;
    var addr_low_tx_busy  : logic;
    var addr_low_tx_finish: logic;
    var addr_low_tx_enable: logic = if (mode == ModePkg::CpuMode::debug) && ~callback_read_rx_busy && ~sequence_count_read_rx_busy && ~debug_busy {
        1
    } else {
        0
    };
    inst addr_low_tx: uarty::Tx (
        CLK                         ,
        RST                         ,
        WE      : addr_low_tx_enable,
        DATA_IN : addr_low          ,
        data_out: addr_low_tx_out   ,
        busy    : addr_low_tx_busy  ,
        finish  : addr_low_tx_finish,
    );

    // assign write_enable = cpu_enable && ~callback_read_rx_busy && ~sequence_count_read_rx_busy && (~debug_busy || (debug_tx_en && (~memory_addr_low_tx_finish || ~memory_addr_high_tx_finish)));
    var memory_addr_low_tx_out   : logic;
    var memory_addr_low_tx_busy  : logic;
    var memory_addr_low_tx_finish: logic;
    var memory_addr_low_tx_enable: logic = if debug_tx_en && ~memory_addr_low_tx_finish {
        1
    } else {
        0
    };
    inst memory_addr_low_tx: uarty::Tx (
        CLK                                ,
        RST                                ,
        WE      : memory_addr_low_tx_enable,
        DATA_IN : addr_low                 ,
        data_out: memory_addr_low_tx_out   ,
        busy    : memory_addr_low_tx_busy  ,
        finish  : memory_addr_low_tx_finish,
    );

    var memory_addr_high_tx_out   : logic;
    var memory_addr_high_tx_busy  : logic;
    var memory_addr_high_tx_finish: logic;
    var memory_addr_high_tx_enable: logic = if debug_tx_en && memory_addr_low_tx_finish {
        1
    } else {
        0
    };
    inst memory_addr_high_tx: uarty::Tx (
        CLK                                 ,
        RST                                 ,
        WE      : memory_addr_high_tx_enable,
        DATA_IN : addr_high                 ,
        data_out: memory_addr_high_tx_out   ,
        busy    : memory_addr_high_tx_busy  ,
        finish  : memory_addr_high_tx_finish,
    );

    // var write_data: logic<8>;
    // assign write_data = if mode == ModePkg::CpuMode::callback {
    //     callback_return_value
    // } else if mode == ModePkg::CpuMode::debug {
    //     if debug_tx_en {
    //         if !memory_addr_low_tx_finish {
    //             addr_low
    //         } else if !memory_addr_high_tx_finish {
    //             addr_high
    //         } else {
    //             0
    //         }
    //     } else {
    //         addr_low
    //     }
    // } else {
    //     7'b0011010
    // };
    // var cpu_enable: logic = mode != ModePkg::CpuMode::nop;

    // var target_addr   : logic<16> = 16'h5;
    // var target_section: logic<16>;
    // assign target_section = CpuMemoryMapPkg::targetSection(target_addr);

    // var write_enable: logic;
    // assign write_enable = cpu_enable && ~callback_read_rx_busy && ~sequence_count_read_rx_busy && (~debug_busy || (debug_tx_en && (~memory_addr_low_tx_finish || ~memory_addr_high_tx_finish)));
    // var write_busy  : logic;
    // var write_finish: logic;
    // inst tx: uarty::Tx (
    //     CLK                   ,
    //     RST                   ,
    //     WE      : write_enable,
    //     DATA_IN : write_data  ,
    //     data_out: GPIO_0_0    ,
    //     busy    : write_busy  ,
    //     finish  : write_finish,
    // );

    var write_busy: logic = callback_tx_busy || memory_addr_low_tx_busy;
    assign GPIO_0_0   = if mode == ModePkg::CpuMode::callback {
        callback_tx_out
    } else if mode == ModePkg::CpuMode::debug {
        if addr_low_tx_enable {
            addr_low_tx_out
        } else {
            1
        }

        // if !memory_addr_low_tx_finish {
        //     memory_addr_low_tx_out
        // } else if !memory_addr_high_tx_finish {
        //     memory_addr_high_tx_out
        // } else if !memory_addr_high_tx_finish {
        // } else {
        //     0
        // }
    } else {
        1
    };
}
