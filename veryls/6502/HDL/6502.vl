module main (
    CLK     : input  logic   ,
    RST     : input  logic   ,
    KEY     : input  logic<3>,
    GPIO_0_0: output logic   ,
    GPIO_0_1: input  logic   ,
) {
    struct CPU {
        register : RegisterPkg::Register        ,
        operators: OperatorsPkg::Operator<8'hff>,
        cycle    : logic                 <15>   ,
    }
    var cpu: CPU;

    function init -> void {
        RegisterPkg::init              ();
        OperatorsPkg::prepare_operators();
        cpu.cycle                       = 0;
    }

    var mode: ModePkg::Mode;
    inst modeHandler: ModeHandler (
        CLK              ,
        RST              ,
        DATA_IN: GPIO_0_1,
        mode             ,
    );

    var callback_read_enable : logic<8> = mode == ModePkg::Mode::callback;
    var callback_return_value: int     ;
    inst callback_read_rx: uarty::Rx (
        CLK                            ,
        RST                            ,
        DATA_IN : GPIO_0_1             ,
        RE      : callback_read_enable ,
        data_out: callback_return_value,
        busy    : 0                    ,
    );

    var sequence_count_read_rx_finish: logic   ;
    var sequence_count_read_rx_enable: logic    = (mode == ModePkg::Mode::sequence) && ~sequence_count_read_rx_finish;
    var sequence_args_count          : logic<8>;
    inst sequence_count_read_rx: uarty::Rx (
        CLK                                    ,
        RST                                    ,
        DATA_IN : GPIO_0_1                     ,
        RE      : sequence_count_read_rx_enable,
        data_out: sequence_args_count          ,
        busy    : 0                            ,
    );

    var write_data: logic<8>;
    assign write_data = if mode == ModePkg::Mode::callback {
        callback_return_value
    } else {
        7'b0011010
    };
    var cpu_enable: logic = mode != ModePkg::Mode::stop;

    var target_addr   : logic<16> = 16'h5;
    var target_section: logic<16>;
    assign target_section = CpuMemoryMapPkg::targetSection(target_addr);

    var read_enable : logic;
    assign read_enable  = cpu_enable && (~write_busy);
    var write_enable: logic;
    assign write_enable = cpu_enable && (~read_busy);
    var read_busy   : logic   ;
    var write_busy  : logic   ;
    var read_buffer : logic<8>;
    inst rx: uarty::Rx (
        CLK                  ,
        RST                  ,
        DATA_IN : GPIO_0_1   ,
        RE      : read_enable,
        data_out: read_buffer,
        busy    : read_busy  ,
    );
    inst tx: uarty::Tx (
        CLK                   ,
        RST                   ,
        WE      : write_enable,
        DATA_IN : write_data  ,
        data_out: GPIO_0_0    ,
        busy    : write_busy  ,
    );
}
