module main (
    CLK     : input  logic   ,
    RST     : input  logic   ,
    KEY     : input  logic<3>,
    HEX0    : output logic<7>,
    GPIO_0_0: output logic   ,
    GPIO_0_1: input  logic   ,
) {
    struct CPU {
        register : RegisterPkg::Register        ,
        operators: OperatorsPkg::Operator<8'hff>,
        cycle    : logic                 <15>   ,
    }
    var cpu: CPU;

    function init -> void {
        RegisterPkg::init              ();
        OperatorsPkg::prepare_operators();
        cpu.cycle                       = 0;
    }

    var mode            : ModePkg::Mode;
    var mode_read_enable: logic         = (~mode_read_finish) && mode == ModePkg::Mode::stop;
    var mode_read_finish: logic        ;
    var mode_read_data  : int          ;
    inst mode_read_rx: uarty::Rx (
        CLK                          ,
        RST                          ,
        DATA_IN    : GPIO_0_1        ,
        RE         : mode_read_enable,
        read_finish: mode_read_finish,
        data_out   : mode_read_data  ,
        busy       : 0               ,
    );
    var mode_selector_enable: logic = mode_read_finish && (mode_read_data != 0);
    inst mode_selector: ModeSelector (
        CLK                       ,
        RST                       ,
        EN  : mode_selector_enable,
        data: mode_read_data      ,
        mode                      ,
    );

    var callback_read_enable : logic<8> = mode_read_finish && (mode == ModePkg::Mode::callback);
    var callback_return_value: int     ;
    inst callback_read_rx: uarty::Rx (
        CLK                               ,
        RST                               ,
        DATA_IN    : GPIO_0_1             ,
        RE         : callback_read_enable ,
        read_finish: 0                    ,
        data_out   : callback_return_value,
        busy       : 0                    ,
    );

    var sequence_count_read_rx_finish: logic   ;
    var sequence_count_read_rx_enable: logic    = (mode == ModePkg::Mode::sequence) && ~sequence_count_read_rx_finish;
    var sequence_args_count          : logic<8>;
    inst sequence_count_read_rx: uarty::Rx (
        CLK                                       ,
        RST                                       ,
        DATA_IN    : GPIO_0_1                     ,
        RE         : sequence_count_read_rx_enable,
        read_finish: sequence_count_read_rx_finish,
        data_out   : sequence_args_count          ,
        busy       : 0                            ,
    );

    var write_data: logic<8>;
    assign write_data = if mode == ModePkg::Mode::callback {
        callback_return_value
    } else {
        7'b0011010
    };
    var cpu_enable: logic = mode != ModePkg::Mode::stop;

    var target_addr   : logic<16> = 16'h5;
    var target_section: logic<16>;
    assign target_section = CpuMemoryMapPkg::targetSection(target_addr);

    var read_enable : logic;
    assign read_enable  = cpu_enable && (~write_busy);
    var write_enable: logic;
    assign write_enable = cpu_enable && (~read_busy);
    var read_finish : logic   ;
    var read_busy   : logic   ;
    var write_busy  : logic   ;
    var read_buffer : logic<8>;
    inst rx: uarty::Rx (
        CLK                     ,
        RST                     ,
        DATA_IN    : GPIO_0_1   ,
        RE         : read_enable,
        read_finish: read_finish,
        data_out   : read_buffer,
        busy       : read_busy  ,
    );
    inst tx: uarty::Tx (
        CLK                   ,
        RST                   ,
        WE      : write_enable,
        DATA_IN : write_data  ,
        data_out: GPIO_0_0    ,
        busy    : write_busy  ,
    );
}
