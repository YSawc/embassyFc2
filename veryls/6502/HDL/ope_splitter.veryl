module OpeSplitter (
    CLK     : input  logic                ,
    RST     : input  logic                ,
    EN      : input  logic                ,
    ope_kind: input  OperatorsPkg::OpeKind,
    ope_mode: output ModePkg::OpeMode     ,
    busy    : output logic                ,
    finish  : output logic                ,
) {
    enum Status: logic<2> {
        Idle,
        Work,
        Finish,
    }
    var status    : Status          ;
    var n_status  : Status          ;
    var n_ope_mode: ModePkg::OpeMode;
    var n_busy    : logic           ;
    var n_finish  : logic           ;
    always_comb {
        n_status   = status;
        n_finish   = finish;
        n_busy     = busy;
        n_ope_mode = ope_mode;
        case status {
            Status::Idle: {
                if EN {
                    n_busy   = 1;
                    n_status = Status::Work;
                }
            }
            Status::Work: {
                n_status = Status::Finish;
                n_busy   = 0;
                if ope_kind == OperatorsPkg::OpeKind::Cmp || ope_kind == OperatorsPkg::OpeKind::Cpx || ope_kind == OperatorsPkg::OpeKind::Cpy {
                    n_ope_mode = ModePkg::OpeMode::Compare;
                } else if ope_kind == OperatorsPkg::OpeKind::Inc || ope_kind == OperatorsPkg::OpeKind::Dec {
                    n_ope_mode = ModePkg::OpeMode::ReadAndStoreToMemory;
                } else if ope_kind == OperatorsPkg::OpeKind::Ora || ope_kind == OperatorsPkg::OpeKind::And || ope_kind == OperatorsPkg::OpeKind::Rti || ope_kind == OperatorsPkg::OpeKind::Rts || ope_kind == OperatorsPkg::OpeKind::Eor || ope_kind == OperatorsPkg::OpeKind::Adc || ope_kind == OperatorsPkg::OpeKind::Sbc || ope_kind == OperatorsPkg::OpeKind::Lda || ope_kind == OperatorsPkg::OpeKind::Ldx || ope_kind == OperatorsPkg::OpeKind::Ldy || ope_kind == OperatorsPkg::OpeKind::Plp || ope_kind == OperatorsPkg::OpeKind::Pla || ope_kind == OperatorsPkg::OpeKind::Bit {
                    n_ope_mode = ModePkg::OpeMode::ReadAndStoreToRegister;
                } else if ope_kind == OperatorsPkg::OpeKind::Asl || ope_kind == OperatorsPkg::OpeKind::Rol || ope_kind == OperatorsPkg::OpeKind::Lsr || ope_kind == OperatorsPkg::OpeKind::Ror {
                    n_ope_mode = ModePkg::OpeMode::ReadAndStoreToAccOrMemory;
                } else if ope_kind == OperatorsPkg::OpeKind::Jsr || ope_kind == OperatorsPkg::OpeKind::Sta || ope_kind == OperatorsPkg::OpeKind::Stx || ope_kind == OperatorsPkg::OpeKind::Sty || ope_kind == OperatorsPkg::OpeKind::Pha || ope_kind == OperatorsPkg::OpeKind::Php {
                    n_ope_mode = ModePkg::OpeMode::StoreToMemory;
                } else {
                    n_ope_mode = ModePkg::OpeMode::Other;
                }
            }
            Status::Finish: {
                n_status = Status::Idle;
            }
        }
        n_finish = n_status == Status::Finish;
    }

    always_ff (posedge CLK, async_high RST) {
        if_reset {
            status   = Status::Idle;
            finish   = 0;
            busy     = 0;
            ope_mode = ModePkg::OpeMode::Nop;
        } else {
            status   = n_status;
            finish   = n_finish;
            busy     = n_busy;
            ope_mode = n_ope_mode;
        }
    }
}
