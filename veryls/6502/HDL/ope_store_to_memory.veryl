module OpeStoreToMemory (
    CLK                    : input   logic                   ,
    RST                    : input   logic                   ,
    EN                     : input   logic                   ,
    WE                     : input   logic                   ,
    DATA_IN                : input   logic                   ,
    ope_kind               : input   OperatorsPkg::OpeKind   ,
    a_target_low_addr      : input   logic                <8>,
    a_target_high_addr     : input   logic                <8>,
    register_slv           : modport RegisterIf::Slave       ,
    register_mst           : modport RegisterIf::Master      ,
    zp_adding_without_carry: input   logic                <8>,
    tx_data_out            : output  logic                   ,
    busy                   : output  logic                   ,
    finish                 : output  logic                   ,
) {
    enum Status: logic<2> {
        Ready,
        WriteMemory,
        Finish,
    }
    var n_status          : Status    ;
    var status            : Status    ;
    var n_tx_data_out     : logic     ;
    var n_busy            : logic     ;
    var n_finish          : logic     ;
    var target_low_addr   : logic <8> ;
    var target_high_addr  : logic <8> ;
    var n_target_low_addr : logic <8> ;
    var n_target_high_addr: logic <8> ;
    var n_s               : logic <8> ;
    var n_p               : logic <8> ;
    var n_pc              : logic <16>;
    var n_send_data       : logic <8> ;
    var send_data         : logic <8> ;
    var write_count       : logic <2> ;
    var n_write_count     : logic <2> ;

    var write_memory_en         : logic;
    assign write_memory_en          = status == Status::WriteMemory;
    var write_memory_tx_data_out: logic;
    var write_memory_busy       : logic;
    var write_memory_finish     : logic;
    inst write_memory: WriteMemory (
        CLK                                       ,
        RST                                       ,
        EN              : write_memory_en         ,
        WE                                        ,
        DATA_IN                                   ,
        target_low_addr                           ,
        target_high_addr                          ,
        send_data                                 ,
        tx_data_out     : write_memory_tx_data_out,
        busy            : write_memory_busy       ,
        finish          : write_memory_finish     ,
    );

    always_comb {
        n_tx_data_out      = tx_data_out;
        n_status           = status;
        n_finish           = finish;
        n_target_low_addr  = target_low_addr;
        n_target_high_addr = target_high_addr;
        n_s                = register_mst.s;
        n_p                = register_mst.p;
        n_pc               = register_mst.pc;
        n_send_data        = send_data;
        n_write_count      = write_count;
        case status {
            Status::Ready: {
                if EN {
                    if write_count == 0 {
                        n_s           = register_slv.s;
                        n_p           = register_slv.p;
                        n_pc          = register_slv.pc;
                        n_write_count = 0;
                    }

                    if ope_kind == OperatorsPkg::OpeKind::Jsr {
                        n_target_low_addr  = n_s;
                        n_target_high_addr = 1;
                        n_s                = utilPkg::wrapping_sub(n_s, 1);
                        if write_count == 0 {
                            n_send_data = (register_slv.pc & 16'hFF00) >> 8;
                        } else {
                            n_send_data = register_slv.pc & 16'h00FF;
                        }
                    } else if ope_kind == OperatorsPkg::OpeKind::Pha || ope_kind == OperatorsPkg::OpeKind::Php {
                        n_s                = RegisterPkg::sub_without_flag(n_p, n_s, 1);
                        n_target_low_addr  = n_s;
                        n_target_high_addr = 1;
                    } else {
                        n_target_low_addr  = a_target_low_addr;
                        n_target_high_addr = a_target_high_addr;
                    }

                    if ope_kind != OperatorsPkg::OpeKind::Jsr {
                        n_send_data = if ope_kind == OperatorsPkg::OpeKind::Sta || ope_kind == OperatorsPkg::OpeKind::Pha {
                            register_slv.a
                        } else if ope_kind == OperatorsPkg::OpeKind::Stx {
                            register_slv.x
                        } else if ope_kind == OperatorsPkg::OpeKind::Sty {
                            register_slv.y
                        } else if ope_kind == OperatorsPkg::OpeKind::Php {
                            register_slv.p
                        } else {
                            0
                        };
                    }
                    n_status = Status::WriteMemory;
                }
            }
            Status::WriteMemory: {
                n_tx_data_out = write_memory_tx_data_out;
                if write_memory_finish {
                    if ope_kind == OperatorsPkg::OpeKind::Jsr {
                        if write_count == 0 {
                            n_write_count += 1;
                            n_status      =  Status::Ready;
                        } else {
                            n_pc     = (a_target_high_addr << 8) + a_target_low_addr;
                            n_status = Status::Finish;
                        }
                    } else {
                        n_status = Status::Finish;
                    }
                }
            }
            Status::Finish: {
                n_status = Status::Ready;
            }
        }
        n_finish = n_status == Status::Finish;
    }

    always_ff (posedge CLK, async_high RST) {
        if_reset {
            tx_data_out      = 0;
            busy             = 0;
            status           = Status::Ready;
            finish           = 0;
            target_low_addr  = 0;
            target_high_addr = 0;
            register_mst.s   = 0;
            register_mst.p   = 0;
            register_mst.pc  = 0;
            send_data        = 0;
            write_count      = 0;
        } else {
            tx_data_out      = n_tx_data_out;
            busy             = n_busy;
            status           = n_status;
            finish           = n_finish;
            target_low_addr  = n_target_low_addr;
            target_high_addr = n_target_high_addr;
            register_mst.s   = n_s;
            register_mst.p   = n_p;
            register_mst.pc  = n_pc;
            send_data        = n_send_data;
            write_count      = n_write_count;
        }
    }
}
