module OpeReadAndStoreToRegister (
    CLK               : input  logic                     ,
    RST               : input  logic                     ,
    EN                : input  logic                     ,
    WE                : input  logic                     ,
    DATA_IN           : input  logic                     ,
    ope_kind          : input  OperatorsPkg::OpeKind     ,
    addr_mode         : input  OperatorsPkg::AddrMode    ,
    a_target_low_addr : input  logic                 <8> ,
    a_target_high_addr: input  logic                 <8> ,
    a_a               : input  logic                 <8> ,
    a_x               : input  logic                 <8> ,
    a_y               : input  logic                 <8> ,
    a_s               : input  logic                 <8> ,
    a_p               : input  logic                 <8> ,
    a_pc              : input  logic                 <16>,
    a                 : output logic                 <8> ,
    x                 : output logic                 <8> ,
    y                 : output logic                 <8> ,
    s                 : output logic                 <8> ,
    p                 : output logic                 <8> ,
    pc                : output logic                 <16>,
    tx_data_out       : output logic                     ,
    RTS               : output logic                     ,
    busy              : output logic                     ,
    finish            : output logic                     ,
) {
    enum Status: logic<2> {
        Ready,
        ReadMemory,
        WriteRegister,
        Finish,
    }
    var n_status          : Status    ;
    var status            : Status    ;
    var n_a               : logic <8> ;
    var n_x               : logic <8> ;
    var n_y               : logic <8> ;
    var n_s               : logic <8> ;
    var n_p               : logic <8> ;
    var n_pc              : logic <16>;
    var n_busy            : logic     ;
    var n_finish          : logic     ;
    var n_register_data   : logic <8> ;
    var register_data     : logic <8> ;
    var target_low_addr   : logic <8> ;
    var n_target_low_addr : logic <8> ;
    var target_high_addr  : logic <8> ;
    var n_target_high_addr: logic <8> ;
    var write_count       : logic <2> ;
    var n_write_count     : logic <2> ;
    var pc_low_tmp        : logic <8> ;
    var n_pc_low_tmp      : logic <8> ;
    var pc_high_tmp       : logic <8> ;
    var n_pc_high_tmp     : logic <8> ;
    var p_tmp             : logic <8> ;
    var n_p_tmp           : logic <8> ;

    var read_memory_en         : logic    = status == Status::ReadMemory;
    var read_memory_target_data: logic<8>;
    var read_memory_tx_data_out: logic   ;
    var read_memory_rts        : logic   ;
    var read_memory_busy       : logic   ;
    var read_memory_finish     : logic   ;
    inst read_memory: ReadMemory (
        CLK                                      ,
        RST                                      ,
        EN              : read_memory_en         ,
        WE                                       ,
        DATA_IN                                  ,
        target_low_addr                          ,
        target_high_addr                         ,
        target_data     : read_memory_target_data,
        tx_data_out     : read_memory_tx_data_out,
        RTS             : read_memory_rts        ,
        busy            : read_memory_busy       ,
        finish          : read_memory_finish     ,
    );

    assign tx_data_out = if status == Status::ReadMemory {
        read_memory_tx_data_out
    } else {
        1
    };

    assign RTS = if status == Status::ReadMemory {
        read_memory_rts
    } else {
        1
    };

    always_comb {
        n_status           = status;
        n_finish           = finish;
        n_a                = a;
        n_x                = x;
        n_y                = y;
        n_s                = s;
        n_p                = p;
        n_pc               = pc;
        n_register_data    = register_data;
        n_target_low_addr  = target_low_addr;
        n_target_high_addr = target_high_addr;
        n_write_count      = write_count;
        n_pc_low_tmp       = pc_low_tmp;
        n_pc_high_tmp      = pc_high_tmp;
        n_p_tmp            = p_tmp;
        case status {
            Status::Ready: {
                n_finish = 0;
                if EN {
                    if write_count == 0 {
                        n_a           = a_a;
                        n_x           = a_x;
                        n_y           = a_y;
                        n_s           = a_s;
                        n_p           = a_p;
                        n_pc          = a_pc;
                        n_pc_low_tmp  = 0;
                        n_pc_high_tmp = 0;
                        n_p_tmp       = 0;
                        n_write_count = 0;
                    }

                    if ope_kind == OperatorsPkg::OpeKind::Rti {
                        n_target_low_addr  = n_s;
                        n_target_high_addr = 1;
                        n_s                = utilPkg::wrapping_add(n_s, 1);
                        n_status           = Status::ReadMemory;
                    } else {
                        if addr_mode == OperatorsPkg::AddrMode::Imm {
                            n_register_data = a_target_low_addr;
                            n_status        = Status::WriteRegister;
                        } else {
                            if ope_kind == OperatorsPkg::OpeKind::Plp || ope_kind == OperatorsPkg::OpeKind::Pla {
                                n_target_low_addr  = n_s;
                                n_target_high_addr = 1;
                                n_s                = RegisterPkg::add_without_flag(n_p, n_s, 1);
                            } else {
                                n_target_low_addr  = a_target_low_addr;
                                n_target_high_addr = a_target_high_addr;
                            }

                            n_status = Status::ReadMemory;
                        }
                    }
                }
            }
            Status::ReadMemory: {
                if read_memory_finish {
                    n_register_data = read_memory_target_data;
                    n_status        = Status::WriteRegister;
                }
            }
            Status::WriteRegister: {
                n_status = Status::Finish;
                if ope_kind == OperatorsPkg::OpeKind::Rti {
                    if write_count == 0 {
                        n_write_count += 1;
                        n_p_tmp       =  register_data;
                        n_status      =  Status::Ready;
                    } else if write_count == 1 {
                        n_write_count += 1;
                        n_pc_low_tmp  =  register_data;
                        n_status      =  Status::Ready;
                    } else if write_count == 2 {
                        n_write_count = 0;
                        n_pc_high_tmp = register_data;
                        n_pc          = (n_pc_high_tmp << 8) + n_pc_low_tmp;
                        n_p           = n_p_tmp;
                    }
                } else if ope_kind == OperatorsPkg::OpeKind::Adc {
                    n_a = RegisterPkg::add_with_vnzc_and_adding_carry(n_p, n_a, register_data);
                } else if ope_kind == OperatorsPkg::OpeKind::Sbc {
                    n_a = RegisterPkg::sub_with_vnzc_and_adding_neg_carry(n_p, n_a, register_data);
                } else if ope_kind == OperatorsPkg::OpeKind::Ora {
                    n_a                 |= register_data;
                    RegisterPkg::set_nz(n_p, n_a);
                } else if ope_kind == OperatorsPkg::OpeKind::And {
                    n_a                 &= register_data;
                    RegisterPkg::set_nz(n_p, n_a);
                } else if ope_kind == OperatorsPkg::OpeKind::Eor {
                    n_a                 ^= register_data;
                    RegisterPkg::set_nz(n_p, n_a);
                } else if ope_kind == OperatorsPkg::OpeKind::Bit {
                    RegisterPkg::set_z(n_p, (register_data & n_a) == 0);
                    RegisterPkg::set_n(n_p, (register_data & 8'b10000000) != 0);
                    RegisterPkg::set_v(n_p, (register_data & 8'b01000000) != 0);
                } else if ope_kind == OperatorsPkg::OpeKind::Lda || ope_kind == OperatorsPkg::OpeKind::Pla {
                    n_a                 = register_data;
                    RegisterPkg::set_nz(n_p, n_a);
                } else if ope_kind == OperatorsPkg::OpeKind::Ldx {
                    n_x                 = register_data;
                    RegisterPkg::set_nz(n_p, n_x);
                } else if ope_kind == OperatorsPkg::OpeKind::Ldy {
                    n_y                 = register_data;
                    RegisterPkg::set_nz(n_p, n_y);
                } else if ope_kind == OperatorsPkg::OpeKind::Plp {
                    n_p = register_data;
                }
            }
            Status::Finish: {
                n_status = Status::Ready;
                n_finish = 1;
            }
        }
    }

    always_ff (posedge CLK, async_high RST) {
        if_reset {
            register_data    = 0;
            a                = 0;
            x                = 0;
            y                = 0;
            s                = 0;
            p                = 0;
            pc               = 0;
            status           = Status::Ready;
            busy             = 0;
            finish           = 0;
            target_low_addr  = 0;
            target_high_addr = 0;
            write_count      = 0;
            pc_low_tmp       = 0;
            pc_high_tmp      = 0;
            p_tmp            = 0;
        } else {
            register_data    = n_register_data;
            a                = n_a;
            x                = n_x;
            y                = n_y;
            s                = n_s;
            p                = n_p;
            pc               = n_pc;
            status           = n_status;
            busy             = n_busy;
            finish           = n_finish;
            target_low_addr  = n_target_low_addr;
            target_high_addr = n_target_high_addr;
            write_count      = n_write_count;
            pc_low_tmp       = n_pc_low_tmp;
            pc_high_tmp      = n_pc_high_tmp;
            p_tmp            = n_p_tmp;
        }
    }
}
