module OpeReadAndStoreToMemory (
    CLK             : input  logic                   ,
    RST             : input  logic                   ,
    EN              : input  logic                   ,
    WE              : input  logic                   ,
    DATA_IN         : input  logic                   ,
    ope_kind        : input  OperatorsPkg::OpeKind   ,
    target_low_addr : input  logic                <8>,
    target_high_addr: input  logic                <8>,
    a_p             : input  logic                <8>,
    p               : output logic                <8>,
    tx_data_out     : output logic                   ,
    RTS             : output logic                   ,
    busy            : output logic                   ,
    finish          : output logic                   ,
) {
    enum Status: logic<2> {
        Ready,
        ReadMemory,
        PreWrite,
        MemoryWrite,
    }
    var n_status: Status   ;
    var status  : Status   ;
    var n_p     : logic <8>;
    var n_busy  : logic    ;
    var n_finish: logic    ;

    var read_memory_en         : logic    = status == Status::ReadMemory;
    var read_memory_target_data: logic<8>;
    var read_memory_tx_data_out: logic   ;
    var read_memory_rts        : logic   ;
    var read_memory_busy       : logic   ;
    var read_memory_finish     : logic   ;
    inst read_memory: ReadMemory (
        CLK                                      ,
        RST                                      ,
        EN              : read_memory_en         ,
        WE                                       ,
        DATA_IN                                  ,
        target_low_addr                          ,
        target_high_addr                         ,
        target_data     : read_memory_target_data,
        tx_data_out     : read_memory_tx_data_out,
        RTS             : read_memory_rts        ,
        busy            : read_memory_busy       ,
        finish          : read_memory_finish     ,
    );

    var assign_data       : logic<8>;
    var n_assign_data     : logic<8>;
    var memory_tx_en      : logic    = WE && status == Status::MemoryWrite;
    var memory_tx_data_out: logic   ;
    var memory_tx_busy    : logic   ;
    var memory_tx_finish  : logic   ;
    inst memory_tx: uarty::Tx (
        CLK                         ,
        RST                         ,
        WE      : memory_tx_en      ,
        DATA_IN : assign_data       ,
        data_out: memory_tx_data_out,
        busy    : memory_tx_busy    ,
        finish  : memory_tx_finish  ,
    );

    assign tx_data_out = if status == Status::ReadMemory {
        read_memory_tx_data_out
    } else if status == Status::MemoryWrite {
        memory_tx_data_out
    } else {
        1
    };

    always_comb {
        n_p           = p;
        n_status      = status;
        n_finish      = finish;
        n_assign_data = assign_data;
        case status {
            Status::Ready: {
                n_finish = 0;
                n_p      = a_p;
                if EN {
                    n_status = Status::ReadMemory;
                }
            }
            Status::ReadMemory: {
                if read_memory_finish {
                    n_status = Status::PreWrite;
                }
            }
            Status::PreWrite: {
                n_assign_data = RegisterPkg::add_with_vnz(n_p, read_memory_target_data, 1);
                n_status      = Status::MemoryWrite;
            }
            Status::MemoryWrite: {
                if memory_tx_finish {
                    n_status = Status::Ready;
                    n_finish = 1;
                }
            }
        }
    }

    always_ff (posedge CLK, async_high RST) {
        if_reset {
            p           = 0;
            status      = Status::Ready;
            assign_data = 0;
            busy        = 0;
            finish      = 0;
        } else {
            p           = n_p;
            status      = n_status;
            assign_data = n_assign_data;
            busy        = n_busy;
            finish      = n_finish;
        }
    }
}
