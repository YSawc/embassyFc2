module OpeReadAndStoreToMemory (
    CLK             : input  logic                   ,
    RST             : input  logic                   ,
    EN              : input  logic                   ,
    WE              : input  logic                   ,
    DATA_IN         : input  logic                   ,
    ope_kind        : input  OperatorsPkg::OpeKind   ,
    target_low_addr : input  logic                <8>,
    target_high_addr: input  logic                <8>,
    a_p             : input  logic                <8>,
    p               : output logic                <8>,
    tx_data_out     : output logic                   ,
    RTS             : output logic                   ,
    busy            : output logic                   ,
    finish          : output logic                   ,
) {
    enum Status: logic<3> {
        Ready,
        ReadMemory,
        PreWrite,
        WriteMemory,
        Finish,
    }
    var n_status   : Status   ;
    var status     : Status   ;
    var n_p        : logic <8>;
    var n_busy     : logic    ;
    var n_finish   : logic    ;
    var n_RTS      : logic    ;
    var n_send_data: logic <8>;
    var send_data  : logic <8>;

    var read_memory_en         : logic    = status == Status::ReadMemory;
    var read_memory_target_data: logic<8>;
    var read_memory_tx_data_out: logic   ;
    var read_memory_rts        : logic   ;
    var read_memory_busy       : logic   ;
    var read_memory_finish     : logic   ;
    inst read_memory: ReadMemory (
        CLK                                      ,
        RST                                      ,
        EN              : read_memory_en         ,
        WE                                       ,
        DATA_IN                                  ,
        target_low_addr                          ,
        target_high_addr                         ,
        target_data     : read_memory_target_data,
        tx_data_out     : read_memory_tx_data_out,
        RTS             : read_memory_rts        ,
        busy            : read_memory_busy       ,
        finish          : read_memory_finish     ,
    );

    var write_memory_en         : logic = status == Status::WriteMemory;
    var write_memory_tx_data_out: logic;
    var write_memory_busy       : logic;
    var write_memory_finish     : logic;
    inst write_memory: WriteMemory (
        CLK                                       ,
        RST                                       ,
        EN              : write_memory_en         ,
        WE                                        ,
        DATA_IN                                   ,
        target_low_addr                           ,
        target_high_addr                          ,
        send_data                                 ,
        tx_data_out     : write_memory_tx_data_out,
        busy            : write_memory_busy       ,
        finish          : write_memory_finish     ,
    );

    assign n_RTS = if status == Status::ReadMemory {
        read_memory_rts
    } else {
        1
    };

    assign tx_data_out = if status == Status::ReadMemory {
        read_memory_tx_data_out
    } else if status == Status::WriteMemory {
        write_memory_tx_data_out
    } else {
        1
    };

    always_comb {
        n_p         = p;
        n_status    = status;
        n_finish    = finish;
        n_send_data = send_data;
        case status {
            Status::Ready: {
                if EN {
                    n_p      = a_p;
                    n_status = Status::ReadMemory;
                }
            }
            Status::ReadMemory: {
                if read_memory_finish {
                    n_status = Status::PreWrite;
                }
            }
            Status::PreWrite: {
                if ope_kind == OperatorsPkg::OpeKind::Inc {
                    n_send_data = RegisterPkg::add_with_nz(n_p, read_memory_target_data, 1);
                } else if ope_kind == OperatorsPkg::OpeKind::Dec {
                    n_send_data = RegisterPkg::sub_with_nz(n_p, read_memory_target_data, 1);
                }
                n_status = Status::WriteMemory;
            }
            Status::WriteMemory: {
                if write_memory_finish {
                    n_status = Status::Finish;
                }
            }
            Status::Finish: {
                n_status = Status::Ready;
            }
        }
        n_finish = n_status == Status::Finish;
    }

    always_ff (posedge CLK, async_high RST) {
        if_reset {
            p         = 0;
            status    = Status::Ready;
            send_data = 0;
            busy      = 0;
            finish    = 0;
            RTS       = 0;
        } else {
            p         = n_p;
            status    = n_status;
            send_data = n_send_data;
            busy      = n_busy;
            finish    = n_finish;
            RTS       = n_RTS;
        }
    }
}
