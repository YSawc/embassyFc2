module OpeReadAndStoreToMemory (
    CLK               : input  logic                    ,
    RST               : input  logic                    ,
    EN                : input  logic                    ,
    WE                : input  logic                    ,
    DATA_IN           : input  logic                    ,
    ope_kind          : input  OperatorsPkg::OpeKind    ,
    a_target_low_addr : input  logic                <8> ,
    a_target_high_addr: input  logic                <8> ,
    a_s               : input  logic                <8> ,
    a_p               : input  logic                <8> ,
    a_pc              : input  logic                <16>,
    s                 : output logic                <8> ,
    p                 : output logic                <8> ,
    pc                : output logic                <16>,
    tx_data_out       : output logic                    ,
    RTS               : output logic                    ,
    busy              : output logic                    ,
    finish            : output logic                    ,
) {
    enum Status: logic<3> {
        Ready,
        ReadMemory,
        PreWrite,
        WriteMemory,
        Finish,
    }
    var n_status          : Status    ;
    var status            : Status    ;
    var n_s               : logic <8> ;
    var n_p               : logic <8> ;
    var n_pc              : logic <16>;
    var n_busy            : logic     ;
    var n_finish          : logic     ;
    var n_RTS             : logic     ;
    var n_send_data       : logic <8> ;
    var send_data         : logic <8> ;
    var write_count       : logic <2> ;
    var n_write_count     : logic <2> ;
    var read_count        : logic <2> ;
    var n_read_count      : logic <2> ;
    var pc_low_tmp        : logic <8> ;
    var n_pc_low_tmp      : logic <8> ;
    var pc_high_tmp       : logic <8> ;
    var n_pc_high_tmp     : logic <8> ;
    var n_target_low_addr : logic <8> ;
    var target_low_addr   : logic <8> ;
    var n_target_high_addr: logic <8> ;
    var target_high_addr  : logic <8> ;

    var read_memory_en         : logic    = status == Status::ReadMemory;
    var read_memory_target_data: logic<8>;
    var read_memory_tx_data_out: logic   ;
    var read_memory_rts        : logic   ;
    var read_memory_busy       : logic   ;
    var read_memory_finish     : logic   ;
    inst read_memory: ReadMemory (
        CLK                                      ,
        RST                                      ,
        EN              : read_memory_en         ,
        WE                                       ,
        DATA_IN                                  ,
        target_low_addr                          ,
        target_high_addr                         ,
        target_data     : read_memory_target_data,
        tx_data_out     : read_memory_tx_data_out,
        RTS             : read_memory_rts        ,
        busy            : read_memory_busy       ,
        finish          : read_memory_finish     ,
    );

    var write_memory_en         : logic = status == Status::WriteMemory;
    var write_memory_tx_data_out: logic;
    var write_memory_busy       : logic;
    var write_memory_finish     : logic;
    inst write_memory: WriteMemory (
        CLK                                       ,
        RST                                       ,
        EN              : write_memory_en         ,
        WE                                        ,
        DATA_IN                                   ,
        target_low_addr                           ,
        target_high_addr                          ,
        send_data                                 ,
        tx_data_out     : write_memory_tx_data_out,
        busy            : write_memory_busy       ,
        finish          : write_memory_finish     ,
    );

    assign n_RTS = if status == Status::ReadMemory {
        read_memory_rts
    } else {
        1
    };

    assign tx_data_out = if status == Status::ReadMemory {
        read_memory_tx_data_out
    } else if status == Status::WriteMemory {
        write_memory_tx_data_out
    } else {
        1
    };

    always_comb {
        n_s                = s;
        n_p                = p;
        n_pc               = pc;
        n_status           = status;
        n_finish           = finish;
        n_send_data        = send_data;
        n_write_count      = write_count;
        n_read_count       = read_count;
        n_pc_low_tmp       = pc_low_tmp;
        n_pc_high_tmp      = pc_high_tmp;
        n_target_low_addr  = target_low_addr;
        n_target_high_addr = target_high_addr;
        case status {
            Status::Ready: {
                if EN {
                    if write_count == 0 && read_count == 0 {
                        n_s  = a_s;
                        n_p  = a_p;
                        n_pc = a_pc;
                    }
                    if ope_kind == OperatorsPkg::OpeKind::Brk {
                        if (n_p & 8'b00000100) == 0 {
                            n_target_low_addr  = n_s;
                            n_target_high_addr = 1;
                            n_s                = utilPkg::wrapping_sub(n_s, 1);
                            if write_count == 0 {
                                n_pc        -= 1;
                                n_send_data =  (a_pc & 16'hFF00) >> 8;
                                n_status    =  Status::WriteMemory;
                            } else if write_count == 1 {
                                n_send_data = a_pc & 16'h00FF;
                                n_status    = Status::WriteMemory;
                            } else if write_count == 2 {
                                n_send_data = a_p;
                                n_status    = Status::WriteMemory;
                            }
                        } else {
                            n_status = Status::Finish;
                        }
                    } else {
                        n_target_low_addr  = a_target_low_addr;
                        n_target_high_addr = a_target_high_addr;
                        n_status           = Status::ReadMemory;
                    }
                }
            }
            Status::ReadMemory: {
                if read_memory_finish {
                    n_status = Status::PreWrite;
                }
            }
            Status::PreWrite: {
                if ope_kind == OperatorsPkg::OpeKind::Brk {
                    if read_count == 0 {
                        n_read_count       += 1;
                        n_target_low_addr  =  8'hFF;
                        n_target_high_addr =  8'hFF;
                        n_pc_high_tmp      =  read_memory_target_data;
                        n_status           =  Status::ReadMemory;
                    } else if read_count == 1 {
                        n_pc_low_tmp  = read_memory_target_data;
                        n_pc          = (n_pc_high_tmp << 8) + n_pc_low_tmp;
                        n_write_count = 0;
                        n_read_count  = 0;
                        n_status      = Status::Finish;
                    }
                } else {
                    if ope_kind == OperatorsPkg::OpeKind::Inc {
                        n_send_data = RegisterPkg::add_with_nz(n_p, read_memory_target_data, 1);
                    } else if ope_kind == OperatorsPkg::OpeKind::Dec {
                        n_send_data = RegisterPkg::sub_with_nz(n_p, read_memory_target_data, 1);
                    }
                    n_status = Status::WriteMemory;
                }
            }
            Status::WriteMemory: {
                if write_memory_finish {
                    if ope_kind == OperatorsPkg::OpeKind::Brk {
                        if write_count <= 1 {
                            n_write_count += 1;
                            n_status      =  Status::Ready;
                        } else if write_count == 2 {
                            n_p                |= 8'b00010100;
                            n_target_low_addr  =  8'hFE;
                            n_target_high_addr =  8'hFF;
                            n_status           =  Status::ReadMemory;
                        }
                    } else {
                        n_status = Status::Finish;
                    }
                }
            }
            Status::Finish: {
                n_status = Status::Ready;
            }
        }
        n_finish = n_status == Status::Finish;
    }

    always_ff (posedge CLK, async_high RST) {
        if_reset {
            s                = 0;
            p                = 0;
            pc               = 0;
            status           = Status::Ready;
            send_data        = 0;
            busy             = 0;
            finish           = 0;
            RTS              = 0;
            target_low_addr  = 0;
            target_high_addr = 0;
            write_count      = 0;
            read_count       = 0;
            pc_low_tmp       = 0;
            pc_high_tmp      = 0;
        } else {
            s                = n_s;
            p                = n_p;
            pc               = n_pc;
            status           = n_status;
            send_data        = n_send_data;
            busy             = n_busy;
            finish           = n_finish;
            RTS              = n_RTS;
            target_low_addr  = n_target_low_addr;
            target_high_addr = n_target_high_addr;
            write_count      = 0;
            write_count      = n_write_count;
            read_count       = n_read_count;
            pc_low_tmp       = n_pc_low_tmp;
            pc_high_tmp      = n_pc_high_tmp;
        }
    }
}
